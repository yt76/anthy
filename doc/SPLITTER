* 文節境界の検出モジュール(splitter)について *
(1)ソースファイル
(2)データ構造
(3)文節の構造
(4)付属語グラフの仕様
(5)メタ文節の種類
(6)素性
(7)文節区切りのアルゴリズム


(1)ソースファイル
このモジュールはsrc-splitter/以下に置かれた下記の
ソースファイルから構成される。

  *splitter.c
    splitterのコンテキストの管理、インターフェース
  *wordlist.c
    文節となりうる文字列を列挙してstruct word_listを構成する。
  *metaword.c
    構成された文節を組み合わせて、よりスコアの
    高いメタ文節struct meta_wordを作りだす。
  *depgraph.c
    付属語グラフの読み込み
    自立語に付属語をつけて、文節を構成する。
  *evalborder.c
    以前は文節の評価を担っていたが、lattice.cにより形骸化しつつある
    他のファイルと統合される可能性が高い
  *lattice.c
    ビタビアルゴリズムによって文節境界を見付ける

splitterの内部のデータは wordborder.hに定義されている．

(2)データ構造
主要な構造体には次のものがある．
  *word_split_info_cache
    一つの文にどのような部分文字列があるかを統一して扱うための構造
    meta_wordの集合を持つ．
  *meta_word
    文節となりうる部分文字列を指す
    word_listが指す文節と同じもの、その文節に記号などを加えたもの、
    学習機能によるものなどが含まれる
  *word_list
    文節となりうる部分文字列を指す

(3)文節の構造
Anthyでは文節が次のような構造をとると仮定している。
自立語部 := 名詞
          | 接頭辞 名詞
          | 名詞 接尾辞
          | 接頭辞 数詞 接尾辞
付属語部 := (付属語グラフで記述された助詞/助動詞などの列)
文節 := 自立語部 付属語部
変換対象の文字列が与えられた際には、その文字列の部分文字列で
この仕様を満たすものを全て列挙する。

(4)付属語グラフの仕様

Anthyでは文節の境界を検出するために文節の
「接頭辞 自立語 接尾辞 付属語」という構成を仮定する。
(付属語は活用語尾を含む)

付属語の部分には助詞や助動詞が一定の規則にしたがって
並んでいるというモデルを採用する。
このならびを次のように定式化する
「@ノード名 "そこに続く単語1" "そこに続く単語2" .. "..n" \
  @遷移するノード名1 @遷移するノード名2 .. @遷移するノード名m」
ノード名がない場合(@のみ)は終端

{遷移の属性}{接続の強さ}@ノードの名前
活用形
 未然 Cz
 連用 Cy
 終止 Cs
 連体 Ct
 仮定 Ck
 命令 Cm
 語幹 Cg
品詞
 動詞、助動詞 v
文節の形式
 格助詞 Sk
 連体修飾語 St
 連用修飾語 Sy
 終端 Se
 付属後なし Sr (文節の情報を消したい時に使う)
 その他の修飾語 Sf

接続の強さ
 なし NORMAL_CONNECTION
 .    WEAK_CONNECTION
 :    WEAKER_CONNECTION

例)
動詞未然形のあとに「れる」「られる」が付属するということを
記述する場合。
indepword.txtには
動詞未然形 @動詞未然形
という記述をすることによって、「動詞未然形」という品詞のあとには
「@動詞未然形」というノード名のノードがくることになる。
次にdepword.master もしくはそこからインクルードされるファイル中に
@動詞未然形 "れる" "られる" @
という記述を行う。
活用形を扱う場合には次のように記述する。
@動詞未然形 "" @れる
@れる "れ" @ない @ず @ば
@れる "れる" S@ @とき


(5)メタ文節の種類
メタ文節には次のようなものがある
 *氏 名
 *連体形 体言
 *名詞 名詞


(6)素性
各文節には品詞と文節の形式(付属語グラフの仕様参照)の情報から素性(feature)
が設定される。
この素性の組み合わせを元にして、文節の連接が正しい変換結果である可能性を計算する。
文節クラスはinclude/segclass.h、
遷移確率はsrc-splitter/transition.hを参照のこと。


(7)文節区切りのアルゴリズム
まず与えられた文字列の中から自立語になりえる部分を列挙し、それに接頭辞、
接尾語、付属語などをつけてword_listを構築する。
この時に(6)の文節クラスを設定する。
次に記号などの一語では文節になり得ない文字を処理したり、学習情報を用い
てmeta_wordを構築する。
このmeta_wordを元に、識別モデルを用いて最もらしい文節の組
み合わせを推定する。
確定された文節の文節クラスは変換候補を決める際にも用いられる。
